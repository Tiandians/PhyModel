# 小球碰撞模型的物理分析、算法设计和基于OpenGL的可视化实现

小组成员：朱宝林、尤比佳、林佳诚、张宏彬
指导老师：黄罗华
摘要：
关键词：

## 第1章 绪论

### 1.1 研究背景
经过几个世纪的发展，数学、物理等基础学科理论已日益完善。随着研究内容越来越深入，其高度抽象的公式无法直观理解，复杂的计算难以靠人力来完成。现代科学研究常以数学、物理等基础学科作为理论基础，而将计算机作为计算和可视化工具。此次研究性学习，我们选取物理学的经典模型——小球碰撞为研究对象，进行物理理论分析，并尝试在计算机上模拟实现以此模型为基础的一些应用场景。

小球碰撞模型在物理研究中具有重要意义。物理学的一个重要方法是理想化模型。当物体自身形状可以忽略时，常常将其简化为小球或质点进行处理。借助小球碰撞模型，物理学家对理想气体的微观运动进行了深入探索。小球碰撞模型还在化学反应动态过程、元素相变、最密堆积问题、天体物理等领域具有广泛应用。

在现代科学研究中，计算机已经成为不可或缺的一环。计算机凭借其强大的性能和高效的算法，能够快速处理海量数据并得到准确的结果。利用可视化技术，研究人员得以实时观察数据情况，获得直观感受

### 1.2 研究目的与意义
通过此次研究，我们希望深入探索小球碰撞这一经典模型，学习物理研究的基本方法；探索在计算机上模拟物理过程，学习使用算法处理大量数据；学习使用图形库将研究结果可视化；学习运用科学研究方法探索、分析并解决问题，实际体验科学研究过程。这将极大地培养我们的和科学研究能力，为我们将来从事科学研究工作打下坚实基础。

### 1.3 研究内容
物理：刚性小球碰撞模型：物体模型、状态模型、过程模型

算法：碰撞检测、事件处理（排序）、驱动模拟

可视化：OpenGL库的使用

### 1.4 研究方法
实验法、文献研究法、模型方法、信息研究方法

## 第2章 物理分析
小球碰撞可以具体地分成三类问题：碰撞预测、检测和处理。为了研究这些问题，需要设计一个物理系统作为基础。

### 2.1 物理建模
一个简单的碰撞系统中有运动的小球和一些固定的障碍物。我们需要建立模型可以分为：实体物理模型、状态物理模型和过程物理模型。

* 实体物理模型：

运动物体：小球（质量m，半径r）

基础固定物体：平面、小球、长方体容器

我们记录平面上一点和法向量来描述平面，记录容器的每一个面来描述容器。

为了方便计算，我们只允许小球运动。质点的运动看起来简单，但它没有几何结构，碰撞方程的解具有不定性。

* 状态物理模型：

固定物体的状态就是它的位置。

小球的运动不需要考虑旋转，它具有的状态量有位置，速度。因为速度在运动过程中不变，所以是关于的线性函数。

### 2.2 过程分析
所有碰撞均为弹性碰撞，不考虑摩擦。

过程分析的方法将决定编程模型：时间驱动模型依赖于碰撞检测，事件驱动模型依赖于碰撞预测。各类物体的碰撞检测都已有非常详尽的研究，可以直接采用。本论文主要使用事件驱动模型，因此使用碰撞预测分析。

#### 2.2.1 碰撞预测

##### 2.2.1.1 球-球
球体占有到球心一定距离内的空间，可以利用空间中两点距离公式确定两球是否发生相撞。

设空间中两球位置分别为 $\vec{p_1}=\left(x_1,y_1,z_1\right)$ 和 $\vec{p_2}=\left(x_2,y_2,z_2\right)$ ，两球速度为 $\vec{v_1}=\left(v_{1x},v_{1y},v_{1z}\right)$ 和 $\vec{v_2}=\left(v_{2x},v_{2y},v_{2z}\right)$ ，两球半径分别为$r_1$,$r_2$。

设两球在t时刻相撞，则有：

$$\left|\left(\vec{p_1}+t\vec{v_1}\right)-\left(\vec{p_2}+t\vec{v_2}\right)\right|=r_1+r_2	(2.1)$$

令 $\Delta\vec{v}=\vec{v_1}-\vec{v_2},\Delta\vec{p}=\vec{p_1}-\vec{p_2}$ 可得一元二次方程：

$$\left|\Delta\vec{v}\right|^2+2\cdot\Delta\vec{v}\cdot\Delta\vec{p}\cdot t+\left|\Delta\vec{p}\right|^2–r1+r22=0	(2.2)$$

$$\Delta=2\sqrt{\left(\Delta\vec{v}\cdot\Delta\vec{p}\right)^2-\left|\Delta\vec{v}\right|^2\left[\left|\Delta\vec{p}\right|^2\left(r_1+r_2\right)^2\right]}	(2.3)$$

计算方程判别式，若判别式 $\Delta\geq0$ 得到方程两根：

$$t_1=\frac{-2\Delta\vec{v}\cdot\Delta\vec{p}+\sqrt\Delta}{2\left|\Delta\vec{v}\right|^2}	t_2=\frac{-2\Delta\vec{v}\cdot\Delta\vec{p}-\sqrt\Delta}{2\left|\Delta\vec{v}\right|^2}	(2.4)$$

对方程根的情况分类讨论，可知：

* 若方程两根均小于0，则两球不会发生碰撞。（负根说明：若时间倒退，两小球可以发生碰撞）
* 若方程两根不都小于0，则两球发生碰撞的时间是最小的非负实根

在实现中，还可以在计算前加上检验措施来提高准确度和效率。

* 提前进行碰撞检测，防止小球出现重叠：
$$\left|\Delta\vec{r}\right|<r_1+r_2	(2.1)$$
若该式为真，则小球重叠。反之未重叠。

* 提前进行相离运动检测，减少计算：
$$\left(\Delta\vec{r}\cdot\vec{v_2}<0\right)\land\left(\Delta\vec{r}\cdot\vec{v_1}>0\right)	(2.1)$$
若该式为真，则小球相离，不可能发生碰撞。


#### 2.2.2 碰撞处理

##### 2.2.2.1 球-球

任何维度的小球碰撞均可转化为沿球心连线方向的一维碰撞，在其他方向上运动状态不变。这是因为小球碰撞时，弹力的方向垂直于小球接触点的切面，从接触点指向球心。
假设t时刻两小球发生碰撞，取该时刻小球位置矢量相减并归一化得到球心连线的方向矢量

$$\widehat{\vec{p_1}-\vec{p_2}}=\vec{p}	(2.5)$$

将两小球的速度与方向矢量点乘得到速度在球心连线方向的分量

$$\vec{v_{10}}\cdot\vec{p}=v_{10}$$
$$\vec{v_{20}}\cdot\vec{p}=v_{20}$$

在球心连线方向上（一维空间）处理小球碰撞，应用《力学》中联立动量、动能守恒方程得到的一维碰撞解

$$v_1=\frac{\left(m_1-m_2\right)v_{10}+2m_2v_{20}}{m_1+m_2}$$	
$$v_2=\frac{\left(m_2-m_1\right)v_{20}+2m_1v_{10}}{m_1+m_2}$$

计算该方向上速度变化量，将变化量乘以方向向量回到三维空间中，再加回原速度

$$\vec{v_1}=\vec{v_{10}}+\left(v_1-v_{10}\right)\cdot\vec{p}$$
$$\vec{v_2}=\vec{v_{20}}+\left(v_2-v_{20}\right)\cdot\vec{p}$$

从而完成了一次小球碰撞的计算


### 2.3 应用

#### 2.3.1 理想气体

* 氧气分子直径0.346e-9m
* 标准状态下气体分子直径2.2414e-3/6.02214076e23开立方根=
* 一微米长度上可排列气体分子数6.452726e+02取为645个
* 一立方微米小球个数268336125
* 花粉粒子直径15～50微米
* OPENGL流畅30fps最大小球个数2096
* 气体分子速率分布均值为0，标准差为2.664195e+02
* 计算过程下图


* k为波尔兹曼常数，k = 1.38066 x 10−23 J/K 
* T=273.16K
* M=5.313393e-26

## 第3章 程序设计
在这一章，我们主要使用UML (Unified Modeling Language, 统一建模语言)来描述我们的程序设计过程。我们采取增量开发方法，先设计基础框架，再一步步加入新功能。

### 3.1 面向对象分析和设计
为了使用计算机实现对上述物理过程的运算，并将其运用到更多模型中，我们将其抽象为程序中的对象。一个简单的碰撞系统应当可以输入数据，根据所需的时间更新系统状态，显示系统当前的状态。图3-1给出了碰撞系统的用户视图。

Figure 用户视图

按第二章物理分析的思路，我们为碰撞系统创建实体类和事件类。实体类保存实体信息并提供实体相关操作；事件类保存事件的信息，并提供对事件的处理（在实现中，处理会转交给具体的实体）。图3-2给出了该碰撞系统的类图，列出了它们的属性和方法。虚线表示公共接口，浅色的类为可选的实现，在增量开发后期才会实现。
要点：一次碰撞事件中必定有一个小球参与。因此，碰撞处理的操作应当全部交给在运动实体类（即实现运动实体与各个实体的碰撞处理。这样做可以提高实现效率，也进一步加强了类之间的封装性。

### 3.2 基础类型API
依照上一节，我们定义了以下抽象数据类型及其API。
小球和墙类：储存数据，并具体处理相关操作。为了简化运算，我们在Ball类中使用了GLM数学库中的向量vec3类表示小球在世界空间中的位置和速度。

> 表格 .事件类型Event的API
Event				
API				
返回类型	函数名和参数列表			说明
	Event(shared_ptr<Ball> ball,shared_ptr<Object> object,float t)			构造函数
float	t()			碰撞时刻
void	handle()			处理事件
数据成员				
成员类型		名称	说明	
shared_ptr<Ball>		ball	参与此次碰撞的小球	
shared_ptr<Object>		object	参与此次碰撞的另一个物体	
float		time	碰撞发生的时刻	
unsigned int		countBall, countObject	计数器，用于判断碰撞是否有效	

事件有效性有两种处理方法：

1. 处理时判断：在类内创建小球碰撞次数的记录。如果在处理该事件时小球的累计碰撞次数发生了变化，则小球已经发生了碰撞，事件失效。
2. 处理时删去：碰撞后，小球的运动轨迹发生改变，与该小球有关的事件均失效，因此可以在每次碰撞后删去与参与碰撞的物体有关的事件。

方法②可以在一定程度上减少内存使用冗余，但方法①减少了访问数组的次数，具有更高的效率。事实上，STL库中的priority_queue优先队列类型并不支持遍历元素，若选择方法②需要自行实现。

事件时间：ball类中的predict方法返回当前时刻距离碰撞发生的时长，而在优先队列中事件按从t=0的初状态开始的时间从小到大排序。因此在创建事件时应当传递predict+currentTime。

### 3.3 碰撞系统程序流程图
图3-4详细地展示了碰撞系统程序的运行流程。总共分为4个模块：主循环，更新循环，处理模块，预测模块。后3个模块都由CollisionSystem类管理，对用户隐藏。

## 第4章 算法分析和实现

### 4.1 算法探究1：时间驱动和事件驱动

### 4.2 算法探究2：包围盒检测

### 4.3 算法探究3：优先队列的长度
若系统较为密集，则短时间内可能发生较多碰撞事件。为了防止内存溢出，又要保证效率最大，应当合理设计优先队列的长度

### 4.4 实验：回退


## 第5章 OpenGL可视化

### 5.1 模型构造

#### 5.1.1 平面绘制
在OpenGL中，一个平面应当具备：顶点坐标、法向量
绘制平面的步骤：


### 5.2 动画：相对时间和绝对时间
由于使用了OpenGL动画，动画的绘制方式是双缓冲，逐帧绘制。为了使模拟尽可能贴近实际，考虑绘制和事件处理时间的关系就尤为重要。
我们以初始化（第一次绘制）作为时间起始点，绘制一条时间轴。每次处理的流程如图。相应时间在时间轴上标出：

## 第6章 模拟实验

### 6.1 速度衰减：台球

### 6.2 引入力和加速度：拥挤的人群

### 6.3 增大数据量：布朗运动

### 6.4 加入参数：温度

## 第7章 参考文献
参考文献1
参考文献2

## 第8章 样式参考集
应用标题：首先应用样式，然后点击列表配置
一个标准表格
元素中间对齐，使用独立样式，释放行距限制，右侧右对齐
		（1.7）

用例：
	(2.2)

