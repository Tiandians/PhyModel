# 算法第四版 学习笔记

## 一、基础

### 1.1 基础编程模型

#### 1.1.1 Java程序的基本结构

#### 1.1.2 原始数据类型和表达式

（表1.1.1 Java程序的基本组成）

（表1.1.2 Java中的原始数据类型）

##### 1.1.2.1 表达式

##### 1.1.2.2 类型转换
##### 1.1.2.3 比较
##### 1.1.2.4 其他原始类型

#### 1.1.3 语句

##### 1.1.3.1 声明语句
##### 1.1.3.2 赋值语句
##### 1.1.3.3 条件语句
##### 1.1.3.4 循环语句
##### 1.1.3.5 break与continue语句

#### 1.1.4 简便记法

##### 1.1.4.1 声明并初始化
##### 1.1.4.2 隐式赋值
##### 1.1.4.3 单语句代码段
##### 1.1.4.4 for语句（表1.1.3 Java语句）

#### 1.1.5 数组

##### 1.1.5.1 创建并初始化数组
##### 1.1.5.2 简化写法
##### 1.1.5.3 使用数组

（表1.1.4 典型的数组处理代码）

##### 1.1.5.4 起别名
##### 1.1.5.5 二维数组

#### 1.1.6 静态方法

（表1.1.5 典型静态方法的实现）

##### 1.1.6.1 静态方法
##### 1.1.6.2 调用静态方法
##### 1.1.6.3 方法的性质

* 方法的参数按值传递
* 方法名可以被重载
* 方法只能返回一个值
* 方法可以产生副作用

##### 1.1.6.4 递归

编写递归代码时最重要的有以下三点：

* 递归总有一个最简单的情况
* 递归调用总是尝试解决一个规模更小的子问题
* 递归调用的父问题和尝试解决的子问题之间不应该有交集

##### 1.1.6.5 基础编程模型

静态方法库是定义在一个Java类中的一组静态方法。类的声明是public class加上类名，以及用花括号包含的静态方法。存放类的文件的文件名和类名相同，扩展名是.java。

##### 1.1.6.6 模块化编程
##### 1.1.6.7 单元测试
##### 1.1.6.8 外部库

#### 1.1.7 API
##### 1.1.7.1 举例
（表1.1.6 Java的数学函数库的API）
##### 1.1.7.2 Java库
（表1.1.7 Java的Array库节选（java.util.Arrays））
##### 1.1.7.3 我们的标准库
（表1.1.8 我们的随机数静态方法库的API）

（表1.1.9 我们的数据分析静态方法库的API）

（表1.1.10 StdRandom库中静态方法的实现）

##### 1.1.7.4 你自己编写的库
* 编写用例，在实现中将计算过程分解成可控的部分
* 明确静态方法库和与之对应的API
* 实现API和一个能够对方法进行独立测试的main()函数
#### 1.1.8 字符串
##### 1.1.8.1字符串拼接
（表1.1.11 Java的String数据类型）
##### 1.1.8.2 类型转换
（表1.1.12 String值和数字之间互相转换的API）
##### 1.1.8.3 自动转换
##### 1.1.8.4 命令行参数

#### 1.1.9 输入输出
##### 1.1.9.1 命令和参数
（表1.1.13 操作系统常用命令）
##### 1.1.9.2 标准输出
（表1.1.14 我们的标准输出库的静态方法的API）
##### 1.1.9.3 格式化输出
（表1.1.15 printf()的格式化方法）
##### 1.1.9.4 标准输入
（表1.1.16 标准输入库中的静态方法的API）
* 输入流由\<ctrl-d\>或\<ctrl-z\>结束
##### 1.1.9.5 重定向与管道
* \> 指定输出
* \< 指定输入
* | 将前面的标准输出和后面的标准输入指定为同一个流
##### 1.1.9.6 基于文件的输入输出
（表1.1.17 我们用于读取和写入数组静态方法的API）
##### 1.1.9.7 标准绘图库（基本方法）
（表1.1.18 标准绘图库的静态（绘图）方法的API）
##### 1.1.9.8 标准绘图库（控制方法）
（表1.1.19 标准绘图库的静态（控制）方法的API）

（表1.1.20 StdDraw绘画举例）

#### 1.1.10 二分查找
##### 1.1.10.1 二分查找

##### 1.1.10.2 开发用例
##### 1.1.10.3 白名单过滤
##### 1.1.10.4 性能
#### 1.1.11 展望

### 1.2 数据抽象
#### 1.2.1 使用抽象数据类型
##### 1.2.1.1 抽象数据类型的API
（表1.2.1 计数器的API）
##### 1.2.1.2 继承的方法
##### 1.2.1.3 用例代码
##### 1.2.1.4 对象
* 对象的三大重要特性：状态（数据类型中的值）、标识（内存中的位置）和行为
##### 1.2.1.5 创建对象（实例化）
* 用new并紧跟类名以及()来触发它的构造函数。它会：
* 为新的对象分配空间
* 调用构造函数初始化对象中的值
* 返回对象的一个引用
##### 1.2.1.6 调用实例方法
* 对象的变量名.实例方法的名称()
* 特别的性质：方法的每次出发都是和一个对象相关的
（表1.2.2 实例方法与静态方法）
##### 1.2.1.7 使用对象
* 应当从引用而非值的角度去考虑问题
##### 1.2.1.8 赋值语句
* 别名：使用引用类型的赋值语句将会创建该引用的一个副本
* 使用原始类型的赋值语句会将值复制到原始类型中
##### 1.2.1.9 将对象作为参数
* 按值传递
* 但使用引用类型作为参数时我们创建的都是别名
* 对于引用类型，这会传递引用的值（复制引用），也就是传递对象的引用
##### 1.2.1.10 将对象作为返回值
##### 1.2.1.11 数组也是对象
##### 1.2.1.12 对象的数组
* 使用方括号语法调用数组的构造函数创建数组
* 对于每个数组元素调用它的构造函数创建相应的对象
* 对象数组是一个由对象的引用组成的数组，而非所有对象本身
总结：

* 数据类型指的是一组值和一组对值的操作的集合
* 对象是能够储存任意该数据类型的值的实体，或数据类型的实例
#### 1.2.2 [Todo]抽象数据类型举例
##### 1.2.2.1 几何对象
##### 1.2.3 [Todo]抽象数据类型的实现

#### 1.2.4 [Todo]更多抽象数据类型的实现
#### 1.2.5 数据类型的设计
##### 1.2.5.1 封装
##### 1.2.5.2 设计API

* API可能会难以实现
* API可能会难以使用
* API可能会范围太窄
* API可能会范围太宽
* API可能会太粗略：无法提供有效抽象
* API可能会太详细：抽象过于细致或是发散而无法使用
* API可能会过于依赖某种特定的数据表示
* 格言：*只为用例提供它们所需要的，仅此而已*
##### 1.2.5.3 [todo]算法与抽象数据类型

### 1.3 背包、队列和栈

#### 1.3.1 API
（表1.3.1 泛型可迭代的基础集合数据类型的API）
##### 1.3.1.1 泛型
##### 1.3.1.2 自动装箱

类型参数必须被实例化为引用类型。Java会自动在引用类型和对应的原始类型之间转换
##### 1.3.1.3 可迭代的类型集合
* 迭代访问：用某种方式处理集合中的每一个元素
* foreach语句：for语句对于集合中的每个元素，执行以下代码段
```java
Queue<Transaction> collection = new Queue<Transaction>();
for(Transaction t : collection)
{ StdOut.println(t);}
```

##### 1.3.1.4 背包

* 性质：背包不支持从中删除元素
* 目的：帮助用例收集元素并迭代遍历所有收集到的元素，迭代顺序不确定且与用例无关
* 用例：计算平均值和标准差

##### 1.3.1.5 先进先出队列

* 目的：保存元素的同时保存相对顺序
* 用例：不知道文件大小的情况下读入数组（读入队列，获取队列大小，创建数组，放入数组）

##### 1.3.1.6 下压栈

* 性质：后进先出
* 目的：保存元素同时颠倒相对顺序
* 用例：逆序排列，无需知道个数

##### 1.3.1.7 算数表达式求值

* 递归定义：算数表达式可能是一个`数`，或者一个`(算数表达式 运算符 算术表达式)`（暂时不省略括号，即不考虑优先级）
>【算法】：Dijkstra的双栈算数表达式求值算法

#### 1.3.2 集合数据类型的实现
##### 1.3.2.1 定容栈
（表1.3.2 一种表示定容字符串栈的抽象数据类型）

（表1.3.3 FixedCapacityStackOfStrings的测试用例的轨迹）

##### 1.3.2.2 泛型

```java
public class FixedCapaticyStack<Item>
```

* Item是一个类型参数，实际的类型必须是引用类型
* 在实现的时候不知道Item的实际类型
* 不允许创建泛型数组，应当使用类型转换
```java
a = (Item[])new Object[cap];
```
（表1.3.4 一种表示泛型定容栈的抽象数据类型）

##### 1.3.2.3 调整数组大小

* 移动数组来创建一个不会溢出的栈，并保证使用率
##### 1.3.2.4 对象游离
* Java回收所有*无法被访问的对象*的内存
* 被弹出的元素的引用仍存在于数组中，这使得Java的垃圾收集策略无法回收内存
* 将弹出的数组元素值设置为null即可
##### 1.3.2.5 迭代
可迭代数据类型的实现，略
>【算法1.1】下压（LIFO）栈（能够动态调整数组大小的实现）

#### 1.3.3 链表
todo
#### 1.3.4 综述
（表1.3.7 基础数据结构）
（表1.3.8 本书所给出的数据结构举例）
在研究时按照以下步骤识别目标并使用抽象数据结构解决问题：

* 定义API
* 根据特定的应用场景开发用例代码
* 描述一种数据结构，并在API所对应的抽象数据类型的实现中根据它定义类的实例变量
* 描述算法，并根据它实现类中的实例方法
* 分析算法的性能特点

### 1.4 算法分析

#### 1.4.1 科学方法
#### 1.4.2 观察

略

#### 1.4.3 数学模型
一个程序运行的总时间主要和两点有关

*  执行每条语句的耗时
*  执行每条语句的频率
##### 1.4.3.1 近似
（表1.4.2 典型的近似）
##### 1.4.3.2 近似运行时间
（表1.4.3 常见的增长数量级函数）
##### 1.4.3.3 对增长数量级的猜想

##### 1.4.3.4 算法的分析

（表1.4.4 程序运行时间的分析）
##### 1.4.3.5 成本模型
##### 1.4.3.6 总结

对于大多数程序，得到其运行时间的数学模型所需步骤如下：

* 确定输入模型，定义问题的规模
* 识别内循环
* 根据内循环中的操作确定成本模型
* 对于给定的输入，判断这些操作的执行频率。这可能需要进行数学分析
（表1.4.5 算法分析中的常见函数）
（表1.4.6 算法分析中常用的近似函数）
#### 1.4.4 增长数量级的分类
（表1.4.7 对增长数量级的常见假设的总结）

#### 1.4.5 设计更快的算法

##### 1.4.5.1 热身运动2-sum
2-sum问题的线性对数级别的解法
##### 1.4.5.2 3-sum问题的快速算法
（表1.4.8 运行时间的总结）
##### 1.4.5.3 下界
（图1.4.6 解决2-sum和3-sum问题的各种算法的成本）
解决各种新问题的步骤：

* 实现并分析该问题的一种简单的解法。称为暴力算法
* 考察算法的各种改进
* 用实验证明新的算法更快
#### 1.4.6 倍率实验
todo
#### 1.4.7 注意事项
##### 1.4.7.1 大常数
##### 1.4.7.2 非决定性的内循环
##### 1.4.7.3 指令时间
##### 1.4.7.4 系统因素
##### 1.4.7.5 不分伯仲
##### 1.4.7.6 对输入的强烈依赖
##### 1.4.7.7 多个问题参量

#### 1.4.8 处理对于输入的依赖
todo
#### 1.4.9 内存
todo
#### 1.4.10 展望

* 不成熟的优化是所有罪恶之源

### 1.5 案例研究：union-find算法
#### 1.5.1 动态连通性

## 二、排序

### 2.1 初级排序算法

关键概念：主键

#### 2.1.1游戏规则

> 【模板】排序算法类的模板
> sort(),less(),exch(),isSorted()

##### 2.1.1.1 验证
##### 2.1.1.2 运行时间

*排序成本模型*：在研究排序算法时，需要计算比较和交换的数量。对于不交换元素的算法，计算访问数组的次数

##### 2.1.1.3 额外的内存使用

排序算法可以分为两类：除了函数调用所需的栈和固定数目的实例变量外无需额外内存的原地排序算法，以及需要额外内存来储存另一份数组副本的其它排序算法

##### 2.1.1.4 数据类型

为希望排序的数据类型实现`Comparable`接口

`compareTo()`方法来定义自然次序。必须实现一个全序关系：自反性、反对称性、传递性

#### 2.1.2 选择排序
> 【算法2.1】选择排序

* 运行时间和输入无关
* 数据移动是最少的：N次交换，线性关系

成本：

* 大约$\frac{n^2}{2}$次比较和$n$次交换

#### 2.1.3 插入排序

对接近有序的数组进行排序要快得多，也适合小规模数组

成本：

* 对于随机排列长度为N且主键不重复的数组：平均情况$\frac{N^2}{4}$次比较和$\frac{N^2}{4}$次交换
* 最坏$\frac{N^2}{2}$次比较和$\frac{N^2}{2}$次交换
* 最简单$N-1$次比较和$0$次交换

几种部分有序的数组：插入排序对它们很有效：

* 每个元素举例它的最终位置都不远
* 一个有序的大数组接一个小数组
* 数组中只有几个元素的位置不正确

#### 2.1.4 排序算法可视化

#### 2.1.5 比较两种排序算法

* 实现并调试它们
* 分析它们的基本性质
* 对它们的相对性能作出猜想
* 用实验验证猜想

#### 2.1.6 希尔排序

概念：递增序列

使数组中任意间隔为h的元素都是有序的，它权衡了子数组的规模和有序性。

排序之初，各个子数组都很短，排序后子数组都是部分有序的，两种情况都很适合插入排序。

重要概念：通过提升速度来解决其他方式无法解决的问题是研究算法的设计和性能的主要原因之一

成本：

* 希尔排序的运行时间不到平方级别
* 已知最坏需要的比较次数和$N^{\frac{3}{2}}$成正比

#### 答疑

排序算法种类多的原因：排序算法的性能都和输入模型有很大关系

#### 习题

### 2.2 归并排序

归并排序是算法设计中分治思想的重要应用

将两个有序数组归并成一个更大的有序数组

优点：能够保证时间和$N\log{N}$成正比

缺点：所需的额外空间和N成正比

#### 2.2.1 原地归并的抽象方法

#### 2.2.2 自顶向下的归并排序

递归调用归并排序

归纳证明算法能够正确排序数组：如果它能将两个子数组排序，它就能够通过归并两个子数组来排序整个数组

成本：

* 需要$\frac{1}{2}N\lg{N}$次到$N\log{N}$次比较
* 最多需要访问数组$6N\lg{N}$次

##### 2.2.2.1 对小规模子数组使用插入排序

##### 2.2.2.2 测试数组是否已经有序

判断a[mid]和a[mid+1]

##### 2.2.2.3 不将元素复制到辅助数组

#### 2.2.3 自底向上的归并排序

先归并微型数组，再成对归并数组

成本：

* 需要$\frac{1}{2}N\lg{N}$次到$N\log{N}$次比较
* 最多需要访问数组$6N\lg{N}$次

适合用链表组织的数据，只需重新组织链表连接就能将链表原地排序

#### 2.2.4 排序算法的复杂度

